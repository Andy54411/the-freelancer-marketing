// src/app/api/create-payment-intent/route.ts
import { NextResponse, type NextRequest } from 'next/server';
import Stripe from 'stripe';

const stripeSecret = process.env.STRIPE_SECRET_KEY;

if (!stripeSecret) {
  console.error("FATAL_ERROR: Die Umgebungsvariable STRIPE_SECRET_KEY ist nicht gesetzt für die API Route /api/create-payment-intent.");
}

const stripe = stripeSecret ? new Stripe(stripeSecret, {
  apiVersion: '2024-06-20', // Stelle sicher, dass dies die aktuelle Stripe API Version ist
}) : null;

export async function POST(request: NextRequest) {
  // DEBUGGING: Logge den Beginn der Anfrage
  console.log("[API /create-payment-intent] POST Anfrage empfangen.");

  if (!stripe) {
    console.error("[API /create-payment-intent] Stripe wurde nicht initialisiert, da STRIPE_SECRET_KEY fehlt.");
    return NextResponse.json({ error: 'Stripe-Konfiguration auf dem Server fehlt.' }, { status: 500 });
  }

  try {
    const body = await request.json();
    console.log("[API /create-payment-intent] Request Body empfangen:", JSON.stringify(body, null, 2));

    // ANPASSUNG: jobPriceInCents statt platformFee erhalten
    const {
      amount, // Dies ist der vom Frontend übermittelte Gesamtbetrag (totalAmountPayableInCents)
      jobPriceInCents, // NEU: Der Basispreis des Dienstleisters vom Frontend
      currency = 'eur',
      connectedAccountId,
      taskId,
      firebaseUserId,
      stripeCustomerId,
      billingDetails, // Rechnungsdetails, falls für zukünftige Nutzung gespeichert werden
    } = body;

    console.log("[API /create-payment-intent] Stripe-Key beginnt mit:", stripeSecret?.slice(0, 10));
    console.log("[API /create-payment-intent] ConnectedAccountId aus Request Body:", connectedAccountId);
    console.log("[API /create-payment-intent] JobPriceInCents aus Request Body:", jobPriceInCents); // NEU: Log

    // Validierung der empfangenen Daten mit detaillierteren Logs
    // ANPASSUNG: amount wird nun später gegen backend-berechneten Wert validiert
    if (typeof amount !== 'number' || amount <= 0) {
      console.error("[API /create-payment-intent] Validierungsfehler: Ungültiger oder fehlender Betrag (amount).", { amount });
      return NextResponse.json({ error: 'Ungültiger Betrag (amount). Muss eine positive Zahl sein.' }, { status: 400 });
    }
    // NEU: Validierung für jobPriceInCents
    if (typeof jobPriceInCents !== 'number' || jobPriceInCents <= 0) {
      console.error("[API /create-payment-intent] Validierungsfehler: Ungültiger oder fehlender Basispreis (jobPriceInCents).", { jobPriceInCents });
      return NextResponse.json({ error: 'Ungültiger Basispreis. Muss eine positive Zahl sein.' }, { status: 400 });
    }
    if (typeof currency !== 'string' || currency.length !== 3) {
      console.error("[API /create-payment-intent] Validierungsfehler: Ungültige Währung.", { currency });
      return NextResponse.json({ error: 'Ungültige Währung.' }, { status: 400 });
    }
    if (!connectedAccountId || typeof connectedAccountId !== 'string' || !connectedAccountId.startsWith('acct_')) {
      console.error("[API /create-payment-intent] Validierungsfehler: Ungültige Connected Account ID.", { connectedAccountId });
      return NextResponse.json({ error: 'Ungültige Connected Account ID. Muss mit "acct_" beginnen.' }, { status: 400 });
    }
    // ANPASSUNG: Entfernung der Validierung für `platformFee`, da sie nicht mehr direkt empfangen wird.
    if (!taskId || typeof taskId !== 'string') {
      console.error("[API /create-payment-intent] Validierungsfehler: Ungültige Task-ID (tempJobDraftId).", { taskId });
      return NextResponse.json({ error: 'Ungültige Task-ID (tempJobDraftId).' }, { status: 400 });
    }
    if (!firebaseUserId || typeof firebaseUserId !== 'string') {
      console.error("[API /create-payment-intent] Validierungsfehler: Ungültige Firebase User ID.", { firebaseUserId });
      return NextResponse.json({ error: 'Ungültige Firebase User ID.' }, { status: 400 });
    }
    // NEU: Automatische Customer-Erstellung für B2B-Unternehmen
    let finalStripeCustomerId = stripeCustomerId;
    if (stripeCustomerId === 'CREATE_CUSTOMER_FOR_COMPANY') {
      console.log("[API /create-payment-intent] Erstelle automatisch Customer ID für Unternehmen...");
      
      const { companyName, customerEmail } = body;
      
      try {
        const customer = await stripe.customers.create({
          email: customerEmail,
          name: companyName || 'Unternehmen',
          metadata: {
            firebaseUserId: firebaseUserId,
            createdFor: 'B2B_booking',
            isCompany: 'true'
          }
        });
        
        finalStripeCustomerId = customer.id;
        console.log("[API /create-payment-intent] Customer ID erfolgreich erstellt:", finalStripeCustomerId);
        
        // TODO: Hier könnte die Customer ID auch in Firestore gespeichert werden
        
      } catch (customerError) {
        console.error("[API /create-payment-intent] Fehler beim Erstellen der Customer ID:", customerError);
        return NextResponse.json({ error: 'Kunde konnte nicht erstellt werden.' }, { status: 500 });
      }
    }
    
    if (!finalStripeCustomerId || typeof finalStripeCustomerId !== 'string' || !finalStripeCustomerId.startsWith('cus_')) {
      console.error("[API /create-payment-intent] Validierungsfehler: Ungültige Stripe Customer ID.", { stripeCustomerId: finalStripeCustomerId });
      return NextResponse.json({ error: 'Ungültige Stripe Customer ID. Muss mit "cus_" beginnen.' }, { status: 400 });
    }
    // NEU: Validierung für billingDetails
    if (!billingDetails || !billingDetails.address?.line1 || !billingDetails.address?.postal_code || !billingDetails.address?.city || !billingDetails.address?.country) {
      console.error("[API /create-payment-intent] Validierungsfehler: Unvollständige Rechnungsadresse.", { billingDetails });
      return NextResponse.json({ error: 'Vollständige Rechnungsadresse ist erforderlich.' }, { status: 400 });
    }


    console.log("[API /create-payment-intent] DEBUG ConnectedAccountId für Stripe (aus Request Body):", `"${connectedAccountId}"`, "Länge:", connectedAccountId.length);

    // --- WARTE-LOGIK FÜR CONNECTED ACCOUNT READINESS (unverändert) ---
    let currentConnectedAccount: Stripe.Account | null = null;
    let attempts = 0;
    const maxAttempts = 15;
    const delayMs = 2000;

    while (attempts < maxAttempts && currentConnectedAccount === null) {
      try {
        currentConnectedAccount = await stripe.accounts.retrieve(connectedAccountId);

        console.log(`[API /create-payment-intent] Versuch ${attempts + 1}/${maxAttempts}. Readiness für ${connectedAccountId}:`,
          `charges_enabled: ${currentConnectedAccount.charges_enabled},`,
          `payouts_enabled: ${currentConnectedAccount.payouts_enabled}`
        );

        if (currentConnectedAccount.charges_enabled && currentConnectedAccount.payouts_enabled) {
          console.log(`[API /create-payment-intent] Connected Account ${connectedAccountId} ist bereit (charges_enabled & payouts_enabled sind true).`);
          break;
        } else {
          console.log(`[API /create-payment-intent] Connected Account ${connectedAccountId} ist noch nicht bereit. Warte ${delayMs / 1000} Sekunden.`);
          await new Promise(resolve => setTimeout(resolve, delayMs));
          attempts++;
        }
      } catch (retrieveError: unknown) {
        let errorMessage = "Unbekannter Fehler beim Abrufen des Connected Accounts.";
        if (retrieveError instanceof Stripe.errors.StripeError) {
          errorMessage = retrieveError.message;
          console.warn(`[API /create-payment-intent] Stripe Fehler beim Abrufen des Connected Accounts ${connectedAccountId} (Versuch ${attempts + 1}):`, errorMessage, retrieveError.type, retrieveError.code);
          if (retrieveError.type === 'StripeInvalidRequestError' && retrieveError.code === 'resource_missing') {
            console.error(`[API /create-payment-intent] Ressource nicht gefunden (Connected Account existiert nicht oder Zugriff verweigert). Beende Warteversuche.`);
            currentConnectedAccount = null;
            break;
          }
          if (retrieveError.type === 'StripeAuthenticationError') {
            console.error(`[API /create-payment-intent] Authentifizierungsfehler mit Stripe API Key. Beende Warteversuche.`);
            currentConnectedAccount = null;
            break;
          }
        } else if (retrieveError instanceof Error) {
          errorMessage = retrieveError.message;
          console.warn(`[API /create-payment-intent] Allgemeiner Fehler beim Abrufen des Connected Accounts ${connectedAccountId} (Versuch ${attempts + 1}):`, errorMessage);
        } else {
          console.warn(`[API /create-payment-intent] Unbekannter Fehler-Typ beim Abrufen des Connected Accounts ${connectedAccountId} (Versuch ${attempts + 1}):`, retrieveError);
        }

        await new Promise(resolve => setTimeout(resolve, delayMs));
        attempts++;
      }
    }

    if (!currentConnectedAccount ||
      !currentConnectedAccount.charges_enabled ||
      !currentConnectedAccount.payouts_enabled) {

      let reason = "ist nicht bereit für Zahlungen oder Auszahlungen.";
      if (currentConnectedAccount) {
        reason = `hat nicht die nötigen Berechtigungen (charges_enabled: ${currentConnectedAccount.charges_enabled}, payouts_enabled: ${currentConnectedAccount.payouts_enabled}).`;
      } else if (currentConnectedAccount === null) {
        reason = `Konto konnte nicht abgerufen werden (möglicherweise nicht existent oder Zugriffsproblem).`;
      }

      console.error(`[API /create-payment-intent] Connected Account ${connectedAccountId} ${reason}`);
      return NextResponse.json({
        error: `Zahlung nicht möglich. Das Anbieter-Konto (${connectedAccountId}) ${reason}`,
        details: 'connected_account_not_ready',
        stripeErrorType: 'api_error'
      }, { status: 500 });
    }
    // --- ENDE DER WARTE-LOGIK ---

    // ANPASSUNG: Neue Gebührenlogik, bei der die Gebühr vom Dienstleister getragen wird.
    const SELLER_SERVICE_FEE_RATE = 0.045; // 4.5% Servicegebühr, die vom Verkäufer (Dienstleister) getragen wird.

    // Der Gesamtbetrag, den der Käufer zahlt, ist jetzt einfach der jobPriceInCents.
    const totalAmountToChargeBuyer = jobPriceInCents;

    // WICHTIGE VALIDIERUNG: Der vom Frontend gesendete Betrag MUSS dem Basispreis entsprechen.
    if (amount !== totalAmountToChargeBuyer) {
      console.error(`[API /create-payment-intent] BETRAGS-INKONSISTENZ: Frontend amount (${amount}) stimmt nicht mit dem Backend-Auftragswert (${totalAmountToChargeBuyer}) überein.`);
      return NextResponse.json({ error: 'Fehler bei der Betragsüberprüfung. Bitte versuchen Sie es erneut.' }, { status: 400 });
    }

    // Die Plattformgebühr (application_fee_amount) ist nun die Gebühr, die vom Verkäufer abgezogen wird.
    const totalApplicationFee = Math.round(jobPriceInCents * SELLER_SERVICE_FEE_RATE);


    console.log(`[API /create-payment-intent] Backend-Berechnungen (NEUE LOGIK):`);
    console.log(`  Basispreis & Gesamtbetrag für Käufer (jobPriceInCents): ${jobPriceInCents} Cents`);
    console.log(`  Plattformgebühr (totalApplicationFee, von Anbieter getragen): ${totalApplicationFee} Cents`);

    // NEU: B2B Guthaben-Prüfung für Unternehmen
    const { isB2BTransaction, payerAccountId } = body;
    let useAccountBalance = false;
    let availableBalance = 0;

    if (isB2BTransaction && payerAccountId && payerAccountId.startsWith('acct_')) {
      console.log(`[API /create-payment-intent] B2B-Transaktion erkannt. Prüfe Guthaben für Account: ${payerAccountId}`);
      
      try {
        // Prüfe das verfügbare Guthaben des Unternehmens-Accounts
        const balance = await stripe.balance.retrieve({
          stripeAccount: payerAccountId
        });
        
        // Verfügbares Guthaben in der gewünschten Währung
        const eurBalance = balance.available.find(b => b.currency === 'eur');
        availableBalance = eurBalance ? eurBalance.amount : 0;
        
        console.log(`[API /create-payment-intent] Verfügbares Guthaben: ${availableBalance} Cents, Benötigt: ${totalAmountToChargeBuyer} Cents`);
        
        if (availableBalance >= totalAmountToChargeBuyer) {
          useAccountBalance = true;
          console.log(`[API /create-payment-intent] Ausreichend Guthaben vorhanden. Verwende Account-to-Account Transfer.`);
        } else {
          console.log(`[API /create-payment-intent] Unzureichendes Guthaben. Fallback auf Kreditkartenzahlung.`);
        }
      } catch (balanceError) {
        console.warn(`[API /create-payment-intent] Fehler beim Abrufen des Guthabens:`, balanceError);
        console.log(`[API /create-payment-intent] Fallback auf Kreditkartenzahlung.`);
      }
    }



    console.log(`[API /create-payment-intent] Konfiguriere PaymentIntent für Client-seitige Bestätigung (keine Weiterleitungen).`);

    let paymentIntentParams: Stripe.PaymentIntentCreateParams;

    if (useAccountBalance) {
      // B2B Account-to-Account Transfer (ohne Kreditkarte)
      console.log(`[API /create-payment-intent] Konfiguriere Account-to-Account Transfer für B2B-Zahlung.`);
      
      // Für Account-to-Account Transfer erstellen wir einen Transfer direkt
      try {
        const transfer = await stripe.transfers.create({
          amount: jobPriceInCents - totalApplicationFee, // Betrag nach Abzug der Plattformgebühr
          currency: currency,
          destination: connectedAccountId,
          source_transaction: undefined, // Kein Payment Intent erforderlich
          metadata: {
            type: 'B2B_account_transfer',
            taskId: taskId,
            payerAccountId: payerAccountId,
            originalAmount: totalAmountToChargeBuyer
          }
        }, {
          stripeAccount: payerAccountId // Transfer vom Payer Account
        });

        console.log(`[API /create-payment-intent] Account-to-Account Transfer erfolgreich:`, transfer.id);
        
        return NextResponse.json({
          success: true,
          transferId: transfer.id,
          paymentMethod: 'account_balance',
          message: 'Zahlung erfolgreich über Guthaben abgewickelt'
        });
        
      } catch (transferError) {
        console.error(`[API /create-payment-intent] Fehler beim Account Transfer:`, transferError);
        // Fallback auf normale Kreditkartenzahlung
        useAccountBalance = false;
      }
    }

    if (!useAccountBalance) {
      // Standard Kreditkarten-Payment Intent
      paymentIntentParams = {
        amount: totalAmountToChargeBuyer, // Der Gesamtbetrag, den der Käufer zahlt
        currency: currency,
        customer: finalStripeCustomerId,
        application_fee_amount: totalApplicationFee, // Die Gesamtgebühr für eure Plattform
        transfer_data: {
          destination: connectedAccountId, // Der Restbetrag geht an den Dienstleister
        },
        confirm: false, // PaymentIntent wird NICHT sofort bestätigt
        setup_future_usage: 'off_session', // Karte für zukünftige Zahlungen speichern
        automatic_payment_methods: {
          enabled: true,
          allow_redirects: 'never', // Verhindert Weiterleitungen
        },
        metadata: {
          tempJobDraftId: taskId,
          firebaseUserId: firebaseUserId,
          paymentMethod: 'credit_card',
          // NEU: Detaillierte Preiskomponenten in den Metadaten speichern
          originalJobPriceInCents: jobPriceInCents.toString(),
          buyerServiceFeeInCents: '0', // Käufer zahlt keine Gebühr mehr
          sellerCommissionInCents: totalApplicationFee.toString(), // Die Gebühr des Verkäufers
          totalPlatformFeeInCents: totalApplicationFee.toString(),
        }
      };

      console.log("[API /create-payment-intent] Erstelle PaymentIntent mit Parametern:", JSON.stringify(paymentIntentParams, null, 2));
      const paymentIntent = await stripe.paymentIntents.create(paymentIntentParams);
      console.log("[API /create-payment-intent] PaymentIntent erfolgreich erstellt:", paymentIntent.id);

      return NextResponse.json({
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
        paymentMethod: 'credit_card'
      });
    }

  } catch (error: unknown) {
    let errorMessage = 'Interner Serverfehler beim Erstellen des PaymentIntents.';
    let stripeErrorCode: string | null = null;
    let stripeErrorType: string | null = null;
    let rawErrorDetails: Stripe.StripeRawError | null = null;

    if (error instanceof Stripe.errors.StripeError) {
      console.error("[API /create-payment-intent] StripeError im Catch-Block:", JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
      errorMessage = `Stripe Fehler: ${error.message}`;
      stripeErrorCode = error.code || null;
      stripeErrorType = error.type;
      const raw = error.raw as Stripe.StripeRawError;
      if (raw && typeof raw.type === 'string') {
        rawErrorDetails = raw;
      }
    } else if (error instanceof Error) {
      console.error("[API /create-payment-intent] Allgemeiner Fehler im Catch-Block:", JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
      errorMessage = error.message;
    } else {
      console.error("[API /create-payment-intent] Unbekannter Fehler im Catch-Block:", JSON.stringify(error, null, 2));
    }

    return NextResponse.json({
      error: errorMessage,
      details: stripeErrorCode,
      stripeErrorType: stripeErrorType,
      raw: rawErrorDetails
    }, { status: 500 });
  }
}
    let errorMessage = 'Interner Serverfehler beim Erstellen des PaymentIntents.';
    let stripeErrorCode: string | null = null;
    let stripeErrorType: string | null = null;
    let rawErrorDetails: Stripe.StripeRawError | null = null;

    if (error instanceof Stripe.errors.StripeError) {
      console.error("[API /create-payment-intent] StripeError im Catch-Block:", JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
      errorMessage = `Stripe Fehler: ${error.message}`;
      stripeErrorCode = error.code || null;
      stripeErrorType = error.type;
      const raw = error.raw as Stripe.StripeRawError;
      if (raw && typeof raw.type === 'string') {
        rawErrorDetails = raw;
      }
    } else if (error instanceof Error) {
      console.error("[API /create-payment-intent] Allgemeiner Fehler im Catch-Block:", JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
      errorMessage = error.message;
    } else {
      console.error("[API /create-payment-intent] Unbekannter Fehler im Catch-Block:", JSON.stringify(error, null, 2));
    }

    return NextResponse.json({
      error: errorMessage,
      details: stripeErrorCode,
      stripeErrorType: stripeErrorType,
      raw: rawErrorDetails
    }, { status: 500 });
  }
}
