import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/firebase/server';
import { FieldValue } from 'firebase-admin/firestore';

export async function POST(request: NextRequest) {
  try {
    const { providerId, quoteData } = await request.json();

    if (!providerId || !quoteData) {
      return NextResponse.json(
        { error: 'Provider ID und Quote-Daten sind erforderlich' },
        { status: 400 }
      );
    }

    // Eindeutige Quote-ID generieren
    const quoteId = `quote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Quote-Anfrage in Firestore speichern
    const quoteRequest = {
      id: quoteId,
      providerId,
      status: 'pending', // pending, reviewed, quoted, accepted, declined
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),

      // Projektdaten
      projectTitle: quoteData.projectTitle,
      projectDescription: quoteData.projectDescription,
      projectCategory: quoteData.projectCategory,
      projectSubcategory: quoteData.projectSubcategory,
      location: quoteData.location,
      postalCode: quoteData.postalCode,
      preferredStartDate: quoteData.preferredStartDate,
      estimatedDuration: quoteData.estimatedDuration,
      budgetRange: quoteData.budgetRange,
      urgency: quoteData.urgency,

      // Kundendaten
      customerName: quoteData.customerName,
      customerEmail: quoteData.customerEmail,
      customerPhone: quoteData.customerPhone,
      additionalNotes: quoteData.additionalNotes,

      // Metadaten
      source: 'website',
      platform: 'taskilo',
    };

    // In quotes Collection speichern
    await setDoc(doc(db, 'quotes', quoteId), quoteRequest);

    // Notification für Provider erstellen
    const notificationId = `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const notification = {
      id: notificationId,
      userId: providerId,
      type: 'quote_request',
      title: 'Neue Angebots-Anfrage',
      message: `${quoteData.customerName} hat ein Angebot für "${quoteData.projectTitle}" angefragt.`,
      data: {
        quoteId,
        projectTitle: quoteData.projectTitle,
        customerName: quoteData.customerName,
        budgetRange: quoteData.budgetRange,
        urgency: quoteData.urgency,
      },
      read: false,
      createdAt: serverTimestamp(),
    };

    await setDoc(doc(db, 'notifications', notificationId), notification);

    // Optional: E-Mail-Benachrichtigung an Provider
    try {
      await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/notifications/email`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'quote_request',
          providerId,
          quoteData,
        }),
      });
    } catch (emailError) {
      console.warn('E-Mail-Benachrichtigung fehlgeschlagen:', emailError);
      // Fehler nicht weiterwerfen, da die Hauptfunktion erfolgreich war
    }

    return NextResponse.json({
      success: true,
      quoteId,
      message: 'Angebots-Anfrage erfolgreich gesendet',
    });
  } catch (error) {
    console.error('Fehler beim Erstellen der Angebots-Anfrage:', error);
    return NextResponse.json(
      { error: 'Interner Serverfehler beim Erstellen der Angebots-Anfrage' },
      { status: 500 }
    );
  }
}
