rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Regeln für die 'companies' Collection
    match /companies/{companyId} {
      allow read: if true;
      allow write: if request.auth != null && request.auth.uid == companyId;
    }

    // Regeln für die 'users' Collection
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Regeln für die 'auftraege' Collection
    match /auftraege/{auftragId} {
      allow read: if request.auth != null
                   && (get(/databases/$(database)/documents/auftraege/$(auftragId)).data.kundeId == request.auth.uid
                       || get(/databases/$(database)/documents/auftraege/$(auftragId)).data.selectedAnbieterId == request.auth.uid);
      allow create, update, delete: if false; // Aufträge sollten vom Backend (Webhook) erstellt/aktualisiert werden
    }

    // --- KORRIGIERTE REGEL: Für die 'temporaryJobDrafts' Collection ---
    match /temporaryJobDrafts/{docId} {
      // Für 'create': Prüfen, ob authentifiziert, Feld existiert, String ist und übereinstimmt
      allow create: if request.auth != null
                     && ('customerFirebaseUid' in request.resource.data)
                     && (request.resource.data.customerFirebaseUid is string)
                     && request.auth.uid == request.resource.data.customerFirebaseUid;

      // Für 'read', 'update', 'delete': Prüfen, ob authentifiziert, Feld existiert, String ist und übereinstimmt
      allow read, update, delete: if request.auth != null
                                   && ('customerFirebaseUid' in resource.data)
                                   && (resource.data.customerFirebaseUid is string)
                                   && request.auth.uid == resource.data.customerFirebaseUid;
    }

    // Regeln für die 'nachrichten' Sub-Collection unter 'auftraege'
    match /auftraege/{auftragId}/nachrichten/{nachrichtId} {
      allow read: if request.auth != null
                     && (get(/databases/$(database)/documents/auftraege/$(auftragId)).data.kundeId == request.auth.uid
                         || get(/databases/$(database)/documents/auftraege/$(auftragId)).data.selectedAnbieterId == request.auth.uid);

        allow create: if request.auth != null
                       && request.resource.data.senderId == request.auth.uid
                       && (get(/databases/$(database)/documents/auftraege/$(auftragId)).data.kundeId == request.auth.uid
                           || get(/databases/$(database)/documents/auftraege/$(auftragId)).data.selectedAnbieterId == request.auth.uid)
                       && request.resource.data.keys().hasAll(['senderId', 'senderName', 'text', 'timestamp', 'senderType'])
                       && request.resource.data.timestamp == request.time;

        allow update, delete: if false;
    }

    // Regeln für die 'supportChats' Collection und 'messages' Sub-Collection
    match /supportChats/{chatId} {
      // Erlaube das Erstellen des Chat-Dokuments selbst nicht direkt durch den Client.
      // Das Dokument wird implizit erstellt, wenn die erste Nachricht geschrieben wird.
      allow read, write: if false;

      match /messages/{messageId} {
        allow read: if request.auth != null
                       // Der Benutzer darf nur Nachrichten lesen, wenn seine UID Teil der chatId ist.
                       // chatId ist im Format 'support_chat_{userId}'
                       && request.auth.uid == chatId.split('_')[2];
        allow create: if request.auth != null
                        && request.auth.uid == chatId.split('_')[2] // Stellt sicher, dass der User nur in seinem Chat schreibt
                        && request.resource.data.senderId == request.auth.uid // Stellt sicher, dass der senderId der des authentifizierten Users ist
                        && request.resource.data.keys().hasAll(['senderId', 'text', 'timestamp']) // Benötigte Felder
                        && request.resource.data.timestamp == request.time; // Stellt sicher, dass der Timestamp vom Server kommt
        allow update, delete: if false; // Nachrichten sollten nicht vom Client aktualisiert/gelöscht werden
      }
    }

    // Fallback-Regel für andere Collections
    match /{collection}/{document} {
      allow read: if request.auth != null;
      allow write: if false;
    }
  }
}
