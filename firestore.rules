rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // üîÅ Rollen anhand des user_type im Firestore-Dokument des Benutzers pr√ºfen
    function isCompany() {
      // Pr√ºft, ob der Benutzer die Rolle 'firma' in seinen Auth-Token-Claims hat.
      // Dies ist die empfohlene, performante Methode zur Rollenpr√ºfung, die rekursive Fehler vermeidet.
      return request.auth != null && 'user_type' in request.auth.token
             && request.auth.token.user_type == 'firma';
    }
    function isAdmin() {
      return request.auth != null && 'role' in request.auth.token
             && request.auth.token.role == 'admin';
    }

    // --- Helper-Funktionen f√ºr Chat-Nachrichten ---
    function isChatParticipant() {
      // Pr√ºft, ob der anfragende Benutzer in der 'chatUsers'-Liste der Nachricht ist.
      return request.auth != null && resource != null && 'chatUsers' in resource.data && request.auth.uid in resource.data.chatUsers;
    }

    function canReadMessage() {
      // Erlaubt das Lesen einer Nachricht, wenn der Benutzer Teilnehmer, Firma oder Admin ist.
      return request.auth != null && (isChatParticipant() || isAdmin());
    }

    function canCreateMessage(requiredFields) {
      // Validiert das Erstellen einer neuen Nachricht.
      return request.auth != null
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.keys().hasAll(requiredFields)
        && request.resource.data.timestamp == request.time
        // Zus√§tzliche Validierung f√ºr Datenintegrit√§t:
        && request.resource.data.chatUsers is list
        && request.resource.data.chatUsers.size() == 2
        && request.auth.uid in request.resource.data.chatUsers; // Der Sender muss selbst Teilnehmer sein
    }

    // --- NEUE HELFER-FUNKTIONEN f√ºr Listen-Berechtigungen ---
    function isAuftragParticipant(auftragId) {
      // KORRIGIERT: Die gesamte Logik muss in einem einzigen return-Statement sein.
      // Der exists()-Check verhindert, dass get() auf ein nicht-existierendes Dokument zugreift.
      // Der 'in'-Check verhindert den Zugriff auf ein nicht-existierendes Feld.
      return exists(/databases/$(database)/documents/auftraege/$(auftragId)) &&
             (
               ('kundeId' in get(/databases/$(database)/documents/auftraege/$(auftragId)).data &&
                get(/databases/$(database)/documents/auftraege/$(auftragId)).data.kundeId == request.auth.uid) ||
               ('selectedAnbieterId' in get(/databases/$(database)/documents/auftraege/$(auftragId)).data &&
                get(/databases/$(database)/documents/auftraege/$(auftragId)).data.selectedAnbieterId == request.auth.uid)
             );
    }

    function isSupportChatParticipant(chatId) {
      // Diese Regel ist sicher, da die Chat-ID direkt von der UID des authentifizierten
      // Benutzers abgeleitet wird. Sie ben√∂tigt keinen Lesezugriff auf das Dokument selbst.
      return request.auth != null && chatId == "support_chat_" + request.auth.uid;
    }

    // --- users Collection ---
    match /users/{userId} {
      // A user should only be able to read their own document.
      // Public data should be in a separate, public collection if needed.
      allow read: if request.auth != null && request.auth.uid == userId;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // --- companies Collection ---
    match /companies/{companyId} {
      // Erlaube √∂ffentlichen Lesezugriff f√ºr Firmenprofile (z.B. f√ºr den Logo-Slider im Hero-Bereich).
      // Schreiboperationen bleiben weiterhin gesch√ºtzt.
      allow read: if true;
      // Allow a user to create their own company document during registration.
      // They do not need the 'company' role yet for this initial step.
      allow create: if request.auth != null
                    && request.auth.uid == companyId;
      // For subsequent updates, the user must have the 'company' role.
      allow update: if request.auth != null
                    && request.auth.uid == companyId
                    && isCompany();
      allow delete: if false; // It's safest to explicitly deny deletes for now.
    }

    // --- auftraege Collection ---
    match /auftraege/{auftragId} {
      allow read: if request.auth != null && resource != null && (
        resource.data.kundeId == request.auth.uid ||
        resource.data.selectedAnbieterId == request.auth.uid ||
        isAdmin()
      );
      allow create,
            update,
            delete: if false;

      // Sub-Collection: nachrichten
      // Hier muss jedes Nachricht-Dokument ein Feld `chatUsers` (Array) enthalten,
      // das alle teilnehmenden UIDs angibt (kunde + anbieter).
      match /nachrichten/{nachrichtId} {
        // 'get' erlaubt Admins/Firmen, eine einzelne Nachricht zu lesen, wenn sie die ID kennen.
        allow get: if canReadMessage();
        // KORRIGIERT: Die komplexe Logik wird in eine wiederverwendbare und sichere Funktion ausgelagert.
        allow list: if request.auth != null && isAuftragParticipant(auftragId);
        allow create: if canCreateMessage([
          "senderId", "senderName", "text", "timestamp", "senderType", "chatUsers"
        ]);
        allow update, delete: if false;
      }
    }

    // --- temporaryJobDrafts Collection ---
    // Diese Dokumente m√ºssen ein Feld `customerFirebaseUid` enthalten.
    match /temporaryJobDrafts/{draftId} {
      allow create: if request.auth != null
                     && request.resource.data.customerFirebaseUid == request.auth.uid;
      allow read, update, delete: if request.auth != null
                                   && resource != null
                                   && resource.data.customerFirebaseUid == request.auth.uid;
    }

    // --- supportChats Collection ---
    // Hier ebenfalls: jede Nachricht im Unterdokument `messages` braucht `chatUsers`.
    match /supportChats/{chatId} {
      allow create: if request.auth != null
                     && request.resource.data.userId == request.auth.uid;
      // KORREKTUR: Erlaube das Lesen, wenn die Chat-ID dem Muster entspricht.
      // Dies l√∂st das "Huhn-Ei-Problem", bei dem man nicht lesen kann, um zu pr√ºfen,
      // ob ein Dokument existiert, weil die Leseregel das existierende Dokument erfordert.
      allow read: if request.auth != null && chatId == "support_chat_" + request.auth.uid;
      // KORREKTUR: Erlaube dem Benutzer, sein eigenes Support-Chat-Dokument zu aktualisieren (z.B. f√ºr lastMessage).
      allow update: if request.auth != null && resource != null
                    && resource.data.userId == request.auth.uid;
      allow delete: if false;

      match /messages/{messageId} {
        // Aufgeteilt in 'get' und 'list' f√ºr mehr Sicherheit bei Abfragen
        allow get: if canReadMessage();
        // KORRIGIERT: Vereinfachte und sichere Regel. Ein Benutzer darf die Nachrichten
        // in seinem eigenen Support-Chat auflisten. Dies vermeidet den fehleranf√§lligen `get()`-Aufruf.
        allow list: if isSupportChatParticipant(chatId);
        allow create: if canCreateMessage([
          "senderId", "text", "timestamp", "chatUsers"
        ]);
        allow update, delete: if false;
      }
    }

    // --- chats Collection (Allgemeine Chats) ---
    // Auch hier: jede Nachricht braucht `chatUsers`.
    match /chats/{chatId} {
      allow read: if request.auth != null && resource != null
                   && ('users' in resource.data)
                   && request.auth.uid in resource.data.users;
      allow create, update: if request.auth != null
                             && ('users' in request.resource.data)
                             && request.auth.uid in request.resource.data.users;
      // NEU: Explizite Regel f√ºr Listenabfragen.
      // Erlaubt eine Abfrage der 'chats'-Sammlung nur, wenn sie explizit
      // nach der UID des angemeldeten Benutzers im 'users'-Array filtert.
      // Dies sichert die `array-contains`-Abfragen in den Inbox-Seiten ab.
      allow list: if (request.auth.uid != null && request.query.where.path == "users" && request.query.where.op == "array-contains" && request.query.where.value == request.auth.uid)
                  || isAdmin(); // Admins d√ºrfen alle Chats f√ºr die Support-Seite auflisten.
      allow delete: if false;

      match /messages/{messageId} {
        // Aufgeteilt in 'get' und 'list' f√ºr mehr Sicherheit bei Abfragen
        allow get: if canReadMessage();
        // KORREKTUR: F√ºr 'list' (Abfragen) ist 'resource' nicht verf√ºgbar.
        // Wir m√ºssen die Berechtigung √ºber einen 'get'-Aufruf auf das Elterndokument pr√ºfen.
        allow list: if request.auth != null
                     && exists(/databases/$(database)/documents/chats/$(chatId))
                     // KORREKTUR: Pr√ºfe, ob 'users' ein Array (list) ist, bevor darauf zugegriffen wird.
                     // Dies ist sicherer als `('users' in ...)` und verhindert Auswertungsfehler,
                     // falls das Feld nicht existiert oder kein Array ist.
                     && get(/databases/$(database)/documents/chats/$(chatId)).data.users is list
                     && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.users;
        allow create: if canCreateMessage([
          "senderId", "text", "timestamp", "chatUsers"
        ]);
        allow update, delete: if false;
      }
    }

    // NEU: Regeln f√ºr die Benachrichtigungs-Sammlung
    match /notifications/{notificationId} {
      // Erlaubt einem Benutzer, seine eigenen Benachrichtigungen zu lesen (sowohl einzeln als auch als Liste).
      // Diese Regel sichert die Abfrage in UserHeader.tsx ab, die `where('userId', '==', uid)` verwendet.
      allow read: if request.auth != null && resource != null && resource.data.userId == request.auth.uid;

      // Erlaubt einem Benutzer, seine eigenen Benachrichtigungen zu aktualisieren (z.B. als gelesen markieren).
      allow update: if request.auth != null && resource != null && resource.data.userId == request.auth.uid;

      // Erlaubt einem authentifizierten Benutzer, eine Benachrichtigung f√ºr sich selbst zu erstellen.
      // Hinweis: In der Regel werden Benachrichtigungen vom Backend (Cloud Functions) erstellt.
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;

      // Erlaubt einem Benutzer, seine eigenen Benachrichtigungen zu l√∂schen.
      allow delete: if request.auth != null && resource != null && resource.data.userId == request.auth.uid;
    }
    // ...weitere Regeln...
  }
}
