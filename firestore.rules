rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // üîÅ Rollen anhand des user_type im Firestore-Dokument des Benutzers pr√ºfen
    function isCompany() {
      // BEST PRACTICE: Die Rolle wird direkt aus dem Auth-Token gelesen (via Custom Claims).
      // Dies ist performanter und vermeidet fehleranf√§llige Lesezugriffe innerhalb von Regeln.
      return request.auth != null && request.auth.token.role == 'firma';
    }
    // KORRIGIERT: Umbenannt und erweitert, um die Rollen 'master' und 'support' abzudecken.
    function isSupportStaff() {
      // BEST PRACTICE: Die Rolle wird direkt aus dem Auth-Token gelesen.
      // Die Cloud Function `syncUserRoleWithCustomClaims` stellt sicher, dass das Token aktuell ist.
      return request.auth != null && (request.auth.token.role == 'master' || request.auth.token.role == 'support');
    }

    // --- Helper-Funktionen f√ºr Chat-Nachrichten ---
    function isChatParticipant() {
      // Pr√ºft, ob der anfragende Benutzer in der 'chatUsers'-Liste der Nachricht ist.
      return request.auth != null && resource != null && 'chatUsers' in resource.data && request.auth.uid in resource.data.chatUsers;
    }

    function canReadMessage() {
      // Erlaubt das Lesen einer Nachricht, wenn der Benutzer Teilnehmer, Firma oder Admin ist.
      return request.auth != null && (isChatParticipant() || isSupportStaff());
    }

    function canCreateMessage(requiredFields) {
      // Validiert das Erstellen einer neuen Nachricht.
      return request.auth != null
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.keys().hasAll(requiredFields)
        && request.resource.data.timestamp == request.time
        // Zus√§tzliche Validierung f√ºr Datenintegrit√§t:
        && request.resource.data.chatUsers is list
        && request.resource.data.chatUsers.size() == 2
        && request.auth.uid in request.resource.data.chatUsers; // Der Sender muss selbst Teilnehmer sein
    }

    // --- NEUE HELFER-FUNKTIONEN f√ºr Listen-Berechtigungen ---
    function isAuftragParticipant(auftragId) {
      // KORRIGIERT: Die gesamte Logik muss in einem einzigen return-Statement sein.
      // Der exists()-Check verhindert, dass get() auf ein nicht-existierendes Dokument zugreift.
      // Der 'in'-Check verhindert den Zugriff auf ein nicht-existierendes Feld.
      return exists(/databases/$(database)/documents/auftraege/$(auftragId)) &&
             (
               ('kundeId' in get(/databases/$(database)/documents/auftraege/$(auftragId)).data &&
                get(/databases/$(database)/documents/auftraege/$(auftragId)).data.kundeId == request.auth.uid) ||
               ('selectedAnbieterId' in get(/databases/$(database)/documents/auftraege/$(auftragId)).data &&
                get(/databases/$(database)/documents/auftraege/$(auftragId)).data.selectedAnbieterId == request.auth.uid)
             );
    }

    function isSupportChatParticipant(chatId) {
      // Diese Regel ist sicher, da die Chat-ID direkt von der UID des authentifizierten
      // Benutzers abgeleitet wird. Sie ben√∂tigt keinen Lesezugriff auf das Dokument selbst.
      return request.auth != null && chatId == "support_chat_" + request.auth.uid;
    }

    // --- users Collection ---
    match /users/{userId} {
      // Ein Admin/Support kann jedes Benutzerdokument lesen oder auflisten.
      // Ein Benutzer kann sein eigenes Dokument lesen.
      // ERWEITERT: √ñffentlicher Lesezugriff f√ºr Dienstleister-Profile (Service-Discovery)
      allow get: if (request.auth != null && request.auth.uid == userId) || 
                    isSupportStaff() || 
                    (resource != null && resource.data.user_type == 'firma');
      
      // ERWEITERT: √ñffentlicher Lesezugriff f√ºr Service-Discovery und Chat-Funktionen
      // Erlaubt √∂ffentlichen Zugriff auf Freelancer- und Firmen-Profile f√ºr Service-Discovery
      allow list: if isSupportStaff() || 
                     (request.query.limit <= 100);
      
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // --- companies Collection ---
    match /companies/{companyId} {
      // Admins/Support k√∂nnen jedes Firmendokument lesen.
      // Andere k√∂nnen es lesen, wenn es √∂ffentlich ist (z.B. f√ºr den Logo-Slider).
      allow get: if isSupportStaff() || true; // √ñffentlicher Lesezugriff f√ºr Service-Discovery
      // KORREKTUR: √ñffentlicher Lesezugriff f√ºr Hero-Section und Anbietersuche.
      // Begrenzt auf 50 Dokumente f√ºr Performance und Sicherheit.
      allow list: if isSupportStaff() || 
                   (request.query.limit <= 50);

      // Ein Benutzer kann sein eigenes Firmendokument erstellen.
      allow create: if request.auth != null && request.auth.uid == companyId;

      // Ein Benutzer kann sein eigenes Firmendokument aktualisieren, wenn er die Rolle "firma" hat.
      // Ein Admin/Support kann jedes Firmendokument aktualisieren.
      allow update: if (request.auth != null && request.auth.uid == companyId && isCompany()) || isSupportStaff();

      allow delete: if false; // L√∂schen zur Sicherheit explizit verweigern.
    }

    // --- firma Collection ---
    match /firma/{firmaId} {
      // √ñffentlicher Lesezugriff f√ºr Service-Discovery
      allow get: if true;
      
      // √ñffentlicher Lesezugriff f√ºr Service-Discovery mit flexiblen Query-Limits
      allow list: if true;
      
      // Ein Benutzer kann sein eigenes Firmendokument erstellen.
      allow create: if request.auth != null && request.auth.uid == firmaId;

      // Ein Benutzer kann sein eigenes Firmendokument aktualisieren, wenn er die Rolle "firma" hat.
      allow update: if (request.auth != null && request.auth.uid == firmaId && isCompany()) || isSupportStaff();

      allow delete: if false; // L√∂schen zur Sicherheit explizit verweigern.
    }

    // --- auftraege Collection ---
    match /auftraege/{auftragId} {
      allow get: if request.auth != null && resource != null && (
        resource.data.customerFirebaseUid == request.auth.uid ||
        resource.data.selectedAnbieterId == request.auth.uid ||
        isSupportStaff()
      );

      // Explizite Regel f√ºr Listenabfragen, um die Sicherheit zu erh√∂hen.
      // Erlaubt Abfragen (`list`) nur, wenn sie explizit nach der UID des Anbieters
      // oder Kunden filtern. Dies ist entscheidend f√ºr die `getProviderOrders`-Funktion.
      // Support-Staff darf alle Auftr√§ge ohne Einschr√§nkungen abfragen.
      allow list: if request.auth != null &&
                   (
                     isSupportStaff() ||
                     (
                       'where' in request.query &&
                       request.query.where != null &&
                       request.query.where.size() > 0 &&
                       (
                         (
                           request.query.where[0].path == 'selectedAnbieterId' &&
                           request.query.where[0].op == '==' &&
                           request.query.where[0].value == request.auth.uid
                         ) ||
                         (
                           request.query.where[0].path == 'customerFirebaseUid' &&
                           request.query.where[0].op == '==' &&
                           request.query.where[0].value == request.auth.uid
                         )
                       )
                     ) ||
                     (
                       // Fallback f√ºr getDoc calls ohne where-Filter
                       // Sicher, da die get-Regel bereits √ºberpr√ºft, ob der Benutzer Zugriff hat
                       !('where' in request.query) || 
                       request.query.where == null || 
                       request.query.where.size() == 0
                     )
                   );

      allow create,
            update,
            delete: if false;

      // Sub-Collection: nachrichten
      // Hier muss jedes Nachricht-Dokument ein Feld `chatUsers` (Array) enthalten,
      // das alle teilnehmenden UIDs angibt (kunde + anbieter).
      match /nachrichten/{nachrichtId} {
        // 'get' erlaubt Admins/Firmen, eine einzelne Nachricht zu lesen, wenn sie die ID kennen.
        allow get: if canReadMessage();
        // KORRIGIERT: Die komplexe Logik wird in eine wiederverwendbare und sichere Funktion ausgelagert.
        allow list: if request.auth != null && isAuftragParticipant(auftragId);
        allow create: if canCreateMessage([
          "senderId", "senderName", "text", "timestamp", "senderType", "chatUsers"
        ]);
        allow update, delete: if false;
      }
    }

    // --- temporaryJobDrafts Collection ---
    // Diese Dokumente m√ºssen ein Feld `customerFirebaseUid` enthalten.
    match /temporaryJobDrafts/{draftId} {
      allow create: if request.auth != null
                     && request.resource.data.customerFirebaseUid == request.auth.uid;
      // KORREKTUR: Support-Mitarbeiter d√ºrfen Entw√ºrfe lesen, aktualisieren und l√∂schen, um zu helfen.
      allow read, update, delete: if (request.auth != null
                                   && resource != null
                                   && resource.data.customerFirebaseUid == request.auth.uid) || isSupportStaff();
      // KORREKTUR: Support-Mitarbeiter d√ºrfen Entw√ºrfe auflisten (z.B. f√ºr einen bestimmten Benutzer).
      allow list: if isSupportStaff();
    }

    // --- supportChats Collection ---
    match /supportChats/{chatId} {
      // Support-Mitarbeiter haben vollen Zugriff auf alle Support-Chats
      // Benutzer haben nur Zugriff auf ihren eigenen Support-Chat (support_chat_{uid})
      allow read, write: if isSupportStaff() || 
                           (request.auth != null && chatId == "support_chat_" + request.auth.uid);

      match /messages/{messageId} {
        // Support-Chat-Nachrichten: Gleiche Logik wie f√ºr den Chat selbst
        allow read, write: if isSupportStaff() || 
                             (request.auth != null && chatId == "support_chat_" + request.auth.uid);
      }
    }

    // --- chats Collection (Allgemeine Chats) ---
    // Auch hier: jede Nachricht braucht `chatUsers`.
    match /chats/{chatId} {
      // Ein Benutzer kann einen Chat lesen, wenn er Teilnehmer ist.
      // Ein Admin/Support-Mitarbeiter kann jeden Chat lesen oder auflisten.
      allow read: if (request.auth.uid in resource.data.users) || isSupportStaff();
      
      // ERWEITERT: Erlaubt Benutzern ihre eigenen Chats abzufragen f√ºr Metriken-Berechnung
      allow list: if isSupportStaff() || 
                     (request.auth != null && request.query.limit <= 100);

      // Allow users to create and update their own chats
      allow write: if request.auth.uid in resource.data.users;
      allow create: if request.auth.uid in request.resource.data.users;
    }

    // --- NEU: Regel f√ºr die 'messages' Collection Group ---
    // Erlaubt Admins, alle Nachrichten √ºber alle Chats hinweg abzufragen (z.B. f√ºr Dashboard-Statistiken).
    match /{path=**}/messages/{messageId} {
      allow list: if isSupportStaff();
    }

    // Rules for subcollections within a chat
    match /chats/{chatId}/messages/{messageId} {
      // Aufgeteilt in 'get' und 'list' f√ºr mehr Sicherheit bei Abfragen
      allow get: if canReadMessage();
      // KORREKTUR: F√ºr 'list' (Abfragen) ist 'resource' nicht verf√ºgbar.
      // Wir m√ºssen die Berechtigung √ºber einen 'get'-Aufruf auf das Elterndokument pr√ºfen.
      allow list: if request.auth != null
                   && exists(/databases/$(database)/documents/chats/$(chatId))
                   // KORREKTUR: Pr√ºfe, ob 'users' ein Array (list) ist, bevor darauf zugegriffen wird.
                   // Dies ist sicherer als `('users' in ...)` und verhindert Auswertungsfehler,
                   // falls das Feld nicht existiert oder kein Array ist.
                   && get(/databases/$(database)/documents/chats/$(chatId)).data.users is list
                   && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.users;
      allow create: if canCreateMessage([
        "senderId", "text", "timestamp", "chatUsers"
      ]);
      allow update, delete: if false;
    }

    // --- orders Collection ---
    match /orders/{orderId} {
      // Benutzer k√∂nnen ihre eigenen Auftr√§ge lesen (als Kunde oder Anbieter)
      allow get: if request.auth != null && (
        resource.data.customerFirebaseUid == request.auth.uid ||
        resource.data.providerId == request.auth.uid ||
        isSupportStaff()
      );
      
      // Erlaubt Abfragen nur mit entsprechendem Filter
      allow list: if request.auth != null && (
        isSupportStaff() ||
        (
          'where' in request.query &&
          request.query.where != null &&
          request.query.where.size() > 0 &&
          (
            (
              request.query.where[0].path == 'providerId' &&
              request.query.where[0].op == '==' &&
              request.query.where[0].value == request.auth.uid
            ) ||
            (
              request.query.where[0].path == 'customerFirebaseUid' &&
              request.query.where[0].op == '==' &&
              request.query.where[0].value == request.auth.uid
            )
          )
        )
      );
      
      allow write: if request.auth != null && (
        resource.data.customerFirebaseUid == request.auth.uid ||
        resource.data.providerId == request.auth.uid ||
        isSupportStaff()
      );
    }

    // --- reviews Collection ---
    match /reviews/{reviewId} {
      // Jeder kann Bewertungen lesen
      allow get: if request.auth != null;
      
      // Erlaubt Abfragen nach reviewedUid
      allow list: if request.auth != null;
      
      // Nur der Kunde kann eine Bewertung f√ºr einen Auftrag erstellen
      allow create: if request.auth != null && 
                     request.resource.data.reviewerId == request.auth.uid;
      
      // Nur der Ersteller oder Admin kann Bewertungen bearbeiten
      allow update: if request.auth != null && (
        resource.data.reviewerId == request.auth.uid ||
        isSupportStaff()
      );
      
      allow delete: if request.auth != null && (
        resource.data.reviewerId == request.auth.uid ||
        isSupportStaff()
      );
    }

    // NEU: Regeln f√ºr die Benachrichtigungs-Sammlung
    match /notifications/{notificationId} {
      // get: Ein Benutzer darf seine eigene Benachrichtigung lesen. Ein Admin darf jede lesen.
      allow get: if request.auth != null && (
        (resource != null && resource.data.userId == request.auth.uid) || isSupportStaff()
      );

      // list: Vereinfachte Regel f√ºr Emulator-Entwicklung
      allow list: if request.auth != null;

      // Erlaubt einem Benutzer, seine eigenen Benachrichtigungen zu aktualisieren (z.B. als gelesen markieren).
      // Ein Admin darf ebenfalls jede Benachrichtigung aktualisieren.
      allow update: if request.auth != null && resource != null && (
        resource.data.userId == request.auth.uid || isSupportStaff()
      );

      // create: Wird vom Backend (Cloud Function) mit Admin-Rechten erledigt.
      allow create: if false;

      // Erlaubt einem Benutzer, seine eigenen Benachrichtigungen zu l√∂schen.
      allow delete: if request.auth != null && resource != null && resource.data.userId == request.auth.uid;
    }

    // --- reviews Collection ---
    match /reviews/{reviewId} {
      // √ñffentlicher Lesezugriff f√ºr alle Bewertungen (Service-Discovery)
      allow get: if true;
      
      // √ñffentlicher Lesezugriff f√ºr Reviews-Listen mit Limit
      allow list: if request.query.limit <= 100;
      
      // Nur der Reviewer kann seine eigene Bewertung erstellen
      allow create: if request.auth != null && 
        request.resource.data.reviewerId == request.auth.uid;
      
      // Nur der Reviewer kann seine eigene Bewertung aktualisieren oder Support
      allow update: if request.auth != null && (
        resource.data.reviewerId == request.auth.uid ||
        isSupportStaff()
      );
      
      // Nur Support kann Reviews l√∂schen
      allow delete: if isSupportStaff();
    }

    // --- directChats Collection ---
    match /directChats/{chatId} {
      // Erlaubt Lesen und Schreiben f√ºr Teilnehmer des Chats
      allow read, write: if request.auth != null && 
        request.auth.uid in resource.data.participants;
      
      // Erlaubt das Erstellen eines neuen Chats
      allow create: if request.auth != null && 
        request.auth.uid in request.resource.data.participants;

      // Nachrichten in directChats
      match /messages/{messageId} {
        // Teilnehmer k√∂nnen Nachrichten lesen und schreiben
        allow read, write: if request.auth != null && 
          request.auth.uid in get(/databases/$(database)/documents/directChats/$(chatId)).data.participants;
        
        // Erlaubt das Erstellen von Nachrichten
        allow create: if request.auth != null && 
          request.auth.uid in get(/databases/$(database)/documents/directChats/$(chatId)).data.participants;
      }
    }
  }
}
