rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // üîÅ Rollen anhand des user_type im Firestore-Dokument des Benutzers pr√ºfen
    function isCompany() {
      // Pr√ºft, ob der anfragende Benutzer in seinem /users/{uid} Dokument den Typ 'firma' hat.
      // Dies ist robuster als sich auf Custom Claims zu verlassen.
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.user_type == 'firma';
    }
    function isAdmin() {
      return request.auth != null && 'role' in request.auth.token
             && request.auth.token.role == 'admin';
    }

    // --- users Collection ---
    match /users/{userId} {
      allow read:  if request.auth != null
                   && (request.auth.uid == userId || isAdmin() || isCompany());
      allow write: if request.auth != null
                   && request.auth.uid == userId;
    }

    // --- companies Collection ---
    match /companies/{companyId} {
      allow read:  if request.auth != null;
      // Allow a user to create their own company document during registration.
      // They do not need the 'company' role yet for this initial step.
      allow create: if request.auth != null
                    && request.auth.uid == companyId;
      // For subsequent updates, the user must have the 'company' role.
      allow update: if request.auth != null
                    && request.auth.uid == companyId
                    && isCompany();
      allow delete: if false; // It's safest to explicitly deny deletes for now.
    }

    // --- auftraege Collection ---
    match /auftraege/{auftragId} {
      allow read:    if request.auth != null
                     && (
                          resource.data.kundeId == request.auth.uid ||
                          resource.data.selectedAnbieterId == request.auth.uid ||
                          isCompany() ||
                          isAdmin()
                        );
      allow create,
            update,
            delete: if false;

      // Sub-Collection: nachrichten
      // Hier muss jedes Nachricht-Dokument ein Feld `chatUsers` (Array) enthalten,
      // das alle teilnehmenden UIDs angibt (kunde + anbieter).
      match /nachrichten/{nachrichtId} {
        // 'get' erlaubt Admins/Firmen, eine einzelne Nachricht zu lesen, wenn sie die ID kennen.
        allow get: if request.auth != null && (
                     ('chatUsers' in resource.data && request.auth.uid in resource.data.chatUsers) ||
                     isCompany() ||
                     isAdmin()
                   );

        // 'list' ist strenger und erfordert, dass die Abfrage nach der UID des Benutzers filtert.
        // Dies stellt sicher, dass Benutzer nur die Chats auflisten k√∂nnen, an denen sie beteiligt sind.
        // Die Client-Abfrage MUSS `where('chatUsers', 'array-contains', currentUser.uid)` enthalten.
        allow list: if request.auth != null &&
                     'chatUsers' in resource.data &&
                     request.auth.uid in resource.data.chatUsers;

        allow create: if request.auth != null
                       && request.resource.data.senderId == request.auth.uid
                       && request.resource.data.keys().hasAll([
                            "senderId", "senderName", "text", "timestamp",
                            "senderType", "chatUsers"
                          ])
                       && request.resource.data.timestamp == request.time;
        allow update, delete: if false;
      }
    }

    // --- temporaryJobDrafts Collection ---
    // Diese Dokumente m√ºssen ein Feld `customerFirebaseUid` enthalten.
    match /temporaryJobDrafts/{draftId} {
      allow create: if request.auth != null
                     && request.resource.data.customerFirebaseUid == request.auth.uid;
      allow read,
            update,
            delete: if request.auth != null
                     && resource.data.customerFirebaseUid == request.auth.uid;
    }

    // --- supportChats Collection ---
    // Hier ebenfalls: jede Nachricht im Unterdokument `messages` braucht `chatUsers`.
    match /supportChats/{chatId} {
      allow create: if request.auth != null
                     && request.resource.data.userId == request.auth.uid;
      allow read:   if request.auth != null
                     && resource.data.userId == request.auth.uid;
      allow update,
            delete: if false;

      match /messages/{messageId} {
        // Aufgeteilt in 'get' und 'list' f√ºr mehr Sicherheit bei Abfragen
        allow get: if request.auth != null && (
                     ('chatUsers' in resource.data && request.auth.uid in resource.data.chatUsers) ||
                     isCompany() ||
                     isAdmin()
                   );
        allow list: if request.auth != null &&
                     'chatUsers' in resource.data &&
                     request.auth.uid in resource.data.chatUsers;

        allow create: if request.auth != null
                       && request.resource.data.senderId == request.auth.uid
                       && request.resource.data.keys().hasAll([
                            "senderId", "text", "timestamp", "chatUsers"
                          ])
                       && request.resource.data.timestamp == request.time;
        allow update, delete: if false;
      }
    }

    // --- chats Collection (Allgemeine Chats) ---
    // Auch hier: jede Nachricht braucht `chatUsers`.
    match /chats/{chatId} {
      allow read: if request.auth != null
                   && ('users' in resource.data)
                   && request.auth.uid in resource.data.users;
      allow create, update: if request.auth != null
                             && ('users' in request.resource.data)
                             && request.auth.uid in request.resource.data.users;
      allow delete: if false;

      match /messages/{messageId} {
        // Aufgeteilt in 'get' und 'list' f√ºr mehr Sicherheit bei Abfragen
        allow get: if request.auth != null && (
                     ('chatUsers' in resource.data && request.auth.uid in resource.data.chatUsers) ||
                     isCompany() ||
                     isAdmin()
                   );
        allow list: if request.auth != null &&
                     'chatUsers' in resource.data &&
                     request.auth.uid in resource.data.chatUsers;

        allow create: if request.auth != null
                       && request.resource.data.senderId == request.auth.uid
                       && request.resource.data.keys().hasAll([
                            "senderId", "text", "timestamp", "chatUsers"
                          ])
                       && request.resource.data.timestamp == request.time;
        allow update, delete: if false;
      }
    }

    match /auftraege/{auftragId}/nachrichten/{nachrichtId} {
      allow list, get: if request.auth != null
        && ('chatUsers' in resource.data)
        && request.auth.uid in resource.data.chatUsers;
      allow create: if request.auth != null
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.keys().hasAll([
             "senderId", "text", "timestamp", "chatUsers"
           ])
        && request.resource.data.timestamp == request.time;
      allow update, delete: if false;
    }
  }
}
