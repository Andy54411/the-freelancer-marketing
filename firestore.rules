rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // üîÅ Rollen anhand des user_type im Firestore-Dokument des Benutzers pr√ºfen
    function isCompany() {
      // Pr√ºft, ob der Benutzer die Rolle 'firma' in seinen Auth-Token-Claims hat.
      // Dies ist die empfohlene, performante Methode zur Rollenpr√ºfung, die rekursive Fehler vermeidet.
      return request.auth != null && 'user_type' in request.auth.token
             && request.auth.token.user_type == 'firma';
    }
    function isAdmin() {
      return request.auth != null && 'role' in request.auth.token
             && request.auth.token.role == 'admin';
    }

    // --- Helper-Funktionen f√ºr Chat-Nachrichten ---
    function isChatParticipant() {
      // Pr√ºft, ob der anfragende Benutzer in der 'chatUsers'-Liste der Nachricht ist.
      return 'chatUsers' in resource.data && request.auth.uid in resource.data.chatUsers;
    }

    function canReadMessage() {
      // Erlaubt das Lesen einer Nachricht, wenn der Benutzer Teilnehmer, Firma oder Admin ist.
      return request.auth != null && (isChatParticipant() || isAdmin());
    }

    function canListMessages() {
      // Erlaubt das Auflisten von Nachrichten nur f√ºr direkte Teilnehmer.
      // Dies erzwingt sichere 'array-contains'-Abfragen auf dem Client.
      return request.auth != null && request.auth.uid in resource.data.chatUsers;
    }

    function canCreateMessage(requiredFields) {
      // Validiert das Erstellen einer neuen Nachricht.
      return request.auth != null
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.keys().hasAll(requiredFields)
        && request.resource.data.timestamp == request.time
        // Zus√§tzliche Validierung f√ºr Datenintegrit√§t:
        && request.resource.data.chatUsers is list
        && request.resource.data.chatUsers.size() == 2
        && request.auth.uid in request.resource.data.chatUsers; // Der Sender muss selbst Teilnehmer sein
    }

    // --- users Collection ---
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // --- companies Collection ---
    match /companies/{companyId} {
      allow read:  if request.auth != null;
      // Allow a user to create their own company document during registration.
      // They do not need the 'company' role yet for this initial step.
      allow create: if request.auth != null
                    && request.auth.uid == companyId;
      // For subsequent updates, the user must have the 'company' role.
      allow update: if request.auth != null
                    && request.auth.uid == companyId
                    && isCompany();
      allow delete: if false; // It's safest to explicitly deny deletes for now.
    }

    // --- auftraege Collection ---
    match /auftraege/{auftragId} {
      allow read:    if request.auth != null
                     && (
                          resource.data.kundeId == request.auth.uid ||
                          resource.data.selectedAnbieterId == request.auth.uid ||
                          isAdmin()
                        );
      allow create,
            update,
            delete: if false;

      // Sub-Collection: nachrichten
      // Hier muss jedes Nachricht-Dokument ein Feld `chatUsers` (Array) enthalten,
      // das alle teilnehmenden UIDs angibt (kunde + anbieter).
      match /nachrichten/{nachrichtId} {
        // 'get' erlaubt Admins/Firmen, eine einzelne Nachricht zu lesen, wenn sie die ID kennen.
        allow get: if canReadMessage();
        allow list: if canListMessages();
        allow create: if canCreateMessage([
          "senderId", "senderName", "text", "timestamp", "senderType", "chatUsers"
        ]);
        allow update, delete: if false;
      }
    }

    // --- temporaryJobDrafts Collection ---
    // Diese Dokumente m√ºssen ein Feld `customerFirebaseUid` enthalten.
    match /temporaryJobDrafts/{draftId} {
      allow create: if request.auth != null
                     && request.resource.data.customerFirebaseUid == request.auth.uid;
      allow read,
            update,
            delete: if request.auth != null
                     && resource.data.customerFirebaseUid == request.auth.uid;
    }

    // --- supportChats Collection ---
    // Hier ebenfalls: jede Nachricht im Unterdokument `messages` braucht `chatUsers`.
    match /supportChats/{chatId} {
      allow create: if request.auth != null
                     && request.resource.data.userId == request.auth.uid;
      allow read:   if request.auth != null
                     && resource.data.userId == request.auth.uid;
      allow update,
            delete: if false;

      match /messages/{messageId} {
        // Aufgeteilt in 'get' und 'list' f√ºr mehr Sicherheit bei Abfragen
        allow get: if canReadMessage();
        allow list: if canListMessages();
        allow create: if canCreateMessage([
          "senderId", "text", "timestamp", "chatUsers"
        ]);
        allow update, delete: if false;
      }
    }

    // --- chats Collection (Allgemeine Chats) ---
    // Auch hier: jede Nachricht braucht `chatUsers`.
    match /chats/{chatId} {
      allow read: if request.auth != null
                   && ('users' in resource.data)
                   && request.auth.uid in resource.data.users;
      allow create, update: if request.auth != null
                             && ('users' in request.resource.data)
                             && request.auth.uid in request.resource.data.users;
      allow delete: if false;

      match /messages/{messageId} {
        // Aufgeteilt in 'get' und 'list' f√ºr mehr Sicherheit bei Abfragen
        allow get: if canReadMessage();
        allow list: if canListMessages();
        allow create: if canCreateMessage([
          "senderId", "text", "timestamp", "chatUsers"
        ]);
        allow update, delete: if false;
      }
    }
    // ...weitere Regeln...
  }
}
